---
layout: post
title:  operation system
categories: operation_system
---
# 1 操作系统的历史

* 多任务处理是操作系统诞生的驱动因素，或者说操作系统解决的问题是如何高效地进行多任务处理

  如果单任务独占，那么不需要操作系统

  发展的进程：

  单任务独占 --> 批处理 --> 多任务处理

* 硬件上

  * 处理器的进步使得计算效率大大提升
  * 内存的增大使得计算机同时装载多个程序成为可能

* 对 cpu 进行分时复用的关键技术是中断

* 虚拟化的目的是提供优秀的 api，让程序的功能得以实现，并且在使用时好像是在独占设备资源

* three easy pieces

  * 虚拟化

    进程，虚拟内存，设备抽象

  * 并发

    cpu 的分时复用，进程/线程间的通信

  * 持久化

    文件系统



# 2 应用眼中的操作系统

* coreutils

  体积更小的替代品，busybox

* ubuntu packages 支持文件名检索

  当系统缺少某些东西时，这是一个非常好的检索入口

* elf

  executable linkable format，可执行的可链接的格式

  * xxd，反汇编命令，可以用来分析 elf 格式的文件
  * readelf，可以用来查看 elf 格式的文件的信息



# 3 多处理器并发编程

* 编译器优化的后的汇编指令会丢失原代码的顺序

  * 保证顺序：volatile，barrier

* 中断机制使得 cpu 在不同程序的汇编指令之间跳转，造成代原码的原子性丢失

  * 保证原子性：multual exclusive

* cpu 在执行指令时，为了增加 cache 的命中率，对于没有依赖的指令会进行重排，例如让一个指令等待一段时间后再去执行，从而丢失了可见性

  * 可见性指的是多个处理器访问共享内存的不能做到一致性，例如一个处理器上执行了写内存指令，对于另一个处理器不可见。

  * 保证可见性：fence 指令，原子性指令



# 4 理解并发程序的执行

* 程序 <==> 有限状态机 <==> 有向图

  有限状态即状态的数目是有限的

  一个状态就是一个时刻内存和寄存器的值

  计算机提供的执行即状态转移的条件

* 计算机提供的指令

  * 确定性的指令，deterministic

  * 非确定性的指令，non-deterministic，例如，

    tdtsc/tdtscp，读取 cpu 的时钟计数

    rdrand，读取传感器上的白噪声，真随机

* syscall 也能够带来不确定性

  这是大部分程序的不确定性的来源

* 程序不确定性的来源

  程序接收操作系统的输入，操作系统接收硬件的输入，硬件接受真实物理世界的输入

* 有限状态机，把它当作一个分析处理问题的工具，它有很多的应用

  * 超标量处理器，superscale

    在一个时钟周期内处理一个等价于多个指令的复合指令，相当于在状态之间跳跃

  * 静态分析，例如静态代码检查，代码调试

    gdb 的回退功能

  * 动态分析，检查运行时状态机的执行

* 举例，利用有限状态机可以证明 perterson 算法的正确性

  * 互斥算法的要求两点：

    safety，坏的情况永远不会发生，即不能出现两个同时进入临界区；

    liveness，好的情况永远会发生，即总有一个能够进入临界区

  * perterson 算法

    ```c
    // 初始
    x = fasle;
    y = false;
    t = t1;
    
    // thread1
    x = true;                  // pc1=1
    t = t1;                    // pc1=2
    while y && t == t2;        // pc1=3
    do_something();  // 临界区  // pc1=4
    x = false;                 // pc1=5
    
    // thread2
    y = true;                  // pc2=1
    t = t2;                    // pc2=2
    while x && t == t1;        // pc2=3
    do_something();  // 临界区  // pc2=4
    y = false;                 // pc2=5
    
    // 共享的内存 x, y, t
    // 各自的程序计数 pc1, pc2
    // 状态 (pc1, pc2, x, y, t)
    // 坏的情况 (4, 4, _, _, _)，safety 即在有向图中这个状态是不可达的
    // 好的情况 (4, !4, _, _, _), (!4, 4, _, _, _)，liveness 即有向图中这两个状态都是可达的，并且不存在可达的环
    // 画有向图可证
    ```

    

